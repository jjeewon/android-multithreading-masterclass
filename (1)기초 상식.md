CPU(Central Processing Unit) 이 작동하는 방법(하이레벨에서)
단순하게 cpu가 박스라고 치고, 밖에서 무엇이 박스 안으로 들어오는지(입력) 생각해보자. 

여기서 입력은 1과 0의 시퀀스임. 각각의 1 또는 0 값은 '비트'라고 부르므로 cpu의 입력은 비트들의 시퀀스.
ex) 1000 1001 1101 1000 = BX 레지스터의 내용을 AX 레지스터로 옮겨라는 커맨드
(레지스터 : cpu의 내부 저장 공간)
위에서 볼 수 있듯이 cpu의 입력값인 비트 시퀀스는 걍 랜덤값이 아니라 cpu가 인식하고 실행할 수 있게하는 커맨드임
cpu가 커맨드로 인식하는 비트 시퀀스는 'instruction(명령어)'라고 부름 
cpu가 인식하는 커맨드들의 총 집합은 cpu instruction set라고 부름 

cpu에 입력할 때는 많은 명령어들로 입력을 함
순서가 있는 명령어 시퀀스로 입력을 하게 되는데, 요 명령어들의 시퀀스를 '머신 코드'라고 부름 
머신 코드는 1과 0으로 이루어진 엄청나게 긴 시퀀스임 
머신 코드는 보통 우리가 읽고 쓸 수 없는 코드임
우리는 고차원 언어로 코드를 작성하고나서 컴파일러를 이용해서 인간이 읽을 수 있는 코드를 머신 코드로 변환함.

즉 멀티스레딩을 이해하기 위해서 cpu를 단순하게 보면 cpu는 하나의 박스고 우리는 요 박스 내부에서 뭔일이 일어나는지 모름.
머신 코드를 요 박스 안에 input으로 넣으면 cpu가 메모리 & 입출력 장치랑 상호작용해서 머신 코드를 처리한 결과가 output으로 나온다는것만 일단 알고 있으면 됨 


System = cpu + os
* 시스템은 cpu(hw)랑 os(sw)의 조합이라고 볼 수 있음 
* os(ex. window, macos, linux)는 하드웨어 capability의 이점을 이용하고 편리하고 효율적인 방식으로 서드파티 앱에게 노출시키기 위해 설계한 특별한 소프트웨어임

Single-Tasking system 
* 단일 테스크의 머신 코드를 테스크가 끝날 때까지 실행하는 것 

Single-Tasking Excution의 예 
* 하나의 프로그램을 위한 머신 코드가 있고, 그 머신 코드는 cpu에 들어가서 실행됨
* 그럼 cpu는 머신코드의 명령어들을 하나하나 실행하기 시작함
* 요 때 뭘 실행하고 있는지를 트래킹하기 위해서 cpu는 'program counter'를 씀 
* 'program counter'는 cpu 내부에 있는 포인터임. 요 포인터가 현재 어떤 명령어를 실행하고 있는지 알려줌
* cpu는 명령어 하나 하나를 실행하는데, 특정 명령어가 들어오면 명령어 몇 개를 뛰어넘을 수도 있음
* 그렇게 처리하다가 특정 시점이 오면 program counter가 프로그램의 마지막 명령어를 가리키게 되고 이후에 프로그램이 끝나게 됨 
* 즉 특정 시점에 pc가 특정 테스크의 마지막 명령어를 가르키게 되고, 그 이후에는 또다른 테스크의 머신 코드가 실행하게 됨
* 하나의 프로그램이 cpu에 로드되는 한, 다른 프로그램은 실행될 수 없고 cpu는 그 프로그램 실행하는데만 쓰이게 됨

single-task 시스템의 장점
* 상대적으로 단순함
* 특정 시점에 단하나의 프로그램의 머신 코드만 돌릴 수 있고 딴 짓은 하지 못함

single-task 시스템의 단점
* single task가 cpu 전체를 독점함
* ex) MS-DOS
* ex) 내 폰 os가 single-task sysem이면 슬랙보다가 인터넷하고 싶을 때 슬랙을 완전히 종료해야지만 인터넷을 시작할 수 있음..

Cooperative multitasking system(상호협력 멀티태스킹 시스템)
* 각각의 실행중인 테스크들은 'yielding'을 통해서 cpu 자원들 release(해제)함 
* 여기서 yielding(양보)은 다른 테스크가 실행할 수 있게하고 나중에 다시 시작하는 것임
* 테스크가 yield하는 동안, 테스크는 cpu 자원을 해제하고, 다른 테스크가 실행될 수 있는 기회를 얻게 됨 
* 일반적으로 yielding과 termination의 차이점은 yield하는 테스크가 나중에 재시작할 것으로 예상되느냐 안되느냐임. 즉 yield는 나중에 다시 시작하는 거고 termination은 걍 끝내는거.
* 즉 테스크가 다른 테스크한테 yield하더라도, 나중에 다시 실행하기 시작할 것임

cooperative multitasking 시스템의 예 
* 만약에 두 가지의 테스크(task1, task2)가 cpu에서 실행되어야 한다고 하자.
* task1에서 instruction들을 실행하다 yield instrunction을 수행하게 되면 cpu는 다른 실행해야하는 task인 task2를 찾게 되고 요거로 전환해서 실행하기 시작함.
* 그러다가 pc가 task2의 yield 명령어를 가리키게 되면 다시 cpu가 다른 실행해야하는 task인 task1을 찾게 되고 다시 task1으로 전환해서 앞에서 yield했던 명령어로 돌아옴.
* 그래서 cpu는 task1에서 실행했던 마지막 명령어부터 다시 시작하게 됨 ..
* 요렇게 cooperative multitasking system은 각각의 테스크가 yield를 하는데 요 때 cpu 리소스를 다른 테스크들에게 해제시켜서 줌 

cooperative multitasking 시스템의 장점
* 여러 테스크가 concurrent하게 실행할 수 있게해줌
* concurrent는 cpu 시간 스케일 관점에서는 글케 많이하는건 아니긴하지만  테스크가 yield를 자주(1초에 백번정도)해서 모든 테스크들이 실행될 수 있는 기회를 가지게 된다는 뜻임 
* 사용자는 백개의 테스크가 '병렬'로 실행되는 것처럼 느끼지만, 실제로는 단일 cpu가 서로 다른 테스크들을 엄청 자주 스위칭해서 실행하고 있는 것임

cooperative multitasking 시스템의 단점
* concurrency는 모든 테스크가 협력할 것으로 예상하지만, 단 하나의 테스크가 잘못되면 cpu를 장시간 갖고 있어서 전체 시스템이 unresponsive하게 될 수 있음..

