CPU(Central Processing Unit) 이 작동하는 방법(하이레벨에서)
단순하게 cpu가 박스라고 치고, 밖에서 무엇이 박스 안으로 들어오는지(입력) 생각해보자. 

여기서 입력은 1과 0의 시퀀스임. 각각의 1 또는 0 값은 '비트'라고 부르므로 cpu의 입력은 비트들의 시퀀스.
ex) 1000 1001 1101 1000 = BX 레지스터의 내용을 AX 레지스터로 옮겨라는 커맨드
(레지스터 : cpu의 내부 저장 공간)
위에서 볼 수 있듯이 cpu의 입력값인 비트 시퀀스는 걍 랜덤값이 아니라 cpu가 인식하고 실행할 수 있게하는 커맨드임
cpu가 커맨드로 인식하는 비트 시퀀스는 'instruction(명령어)'라고 부름 
cpu가 인식하는 커맨드들의 총 집합은 cpu instruction set라고 부름 

cpu에 입력할 때는 많은 명령어들로 입력을 함
순서가 있는 명령어 시퀀스로 입력을 하게 되는데, 요 명령어들의 시퀀스를 '머신 코드'라고 부름 
머신 코드는 1과 0으로 이루어진 엄청나게 긴 시퀀스임 
머신 코드는 보통 우리가 읽고 쓸 수 없는 코드임
우리는 고차원 언어로 코드를 작성하고나서 컴파일러를 이용해서 인간이 읽을 수 있는 코드를 머신 코드로 변환함.

즉 멀티스레딩을 이해하기 위해서 cpu를 단순하게 보면 cpu는 하나의 박스고 우리는 요 박스 내부에서 뭔일이 일어나는지 모름.
머신 코드를 요 박스 안에 input으로 넣으면 cpu가 메모리 & 입출력 장치랑 상호작용해서 머신 코드를 처리한 결과가 output으로 나온다는것만 일단 알고 있으면 됨 


System = cpu + os
* 시스템은 cpu(hw)랑 os(sw)의 조합이라고 볼 수 있음 
* os(ex. window, macos, linux)는 하드웨어 capability의 이점을 이용하고 편리하고 효율적인 방식으로 서드파티 앱에게 노출시키기 위해 설계한 특별한 소프트웨어임

Single-Tasking system 
* 단일 테스크의 머신 코드를 테스크가 끝날 때까지 실행하는 것 

Single-Tasking Excution의 예 
* 하나의 프로그램을 위한 머신 코드가 있고, 그 머신 코드는 cpu에 들어가서 실행됨
* 그럼 cpu는 머신코드의 명령어들을 하나하나 실행하기 시작함
* 요 때 뭘 실행하고 있는지를 트래킹하기 위해서 cpu는 'program counter'를 씀 
* 'program counter'는 cpu 내부에 있는 포인터임. 요 포인터가 현재 어떤 명령어를 실행하고 있는지 알려줌
* cpu는 명령어 하나 하나를 실행하는데, 특정 명령어가 들어오면 명령어 몇 개를 뛰어넘을 수도 있음
* 그렇게 처리하다가 특정 시점이 오면 program counter가 프로그램의 마지막 명령어를 가리키게 되고 이후에 프로그램이 끝나게 됨 
* 즉 특정 시점에 pc가 특정 테스크의 마지막 명령어를 가르키게 되고, 그 이후에는 또다른 테스크의 머신 코드가 실행하게 됨
* 하나의 프로그램이 cpu에 로드되는 한, 다른 프로그램은 실행될 수 없고 cpu는 그 프로그램 실행하는데만 쓰이게 됨

single-task 시스템의 장점
* 상대적으로 단순함
* 특정 시점에 단하나의 프로그램의 머신 코드만 돌릴 수 있고 딴 짓은 하지 못함

single-task 시스템의 단점
* single task가 cpu 전체를 독점함
* ex) MS-DOS
* ex) 내 폰 os가 single-task sysem이면 슬랙보다가 인터넷하고 싶을 때 슬랙을 완전히 종료해야지만 인터넷을 시작할 수 있음..
